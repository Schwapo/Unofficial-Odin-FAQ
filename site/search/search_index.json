{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello My name is Antonio Rafael Antunes Miranda. I've created this website to answer frequently asked questions from the Odin Inspector Discord Channel . I will try to update this repository whenever I feel that a question is getting asked a lot and I have an answer for it. Info This is not an official Odin FAQ and I'm not in any way associated with Sirenix.","title":"Home"},{"location":"#hello","text":"My name is Antonio Rafael Antunes Miranda. I've created this website to answer frequently asked questions from the Odin Inspector Discord Channel . I will try to update this repository whenever I feel that a question is getting asked a lot and I have an answer for it. Info This is not an official Odin FAQ and I'm not in any way associated with Sirenix.","title":"Hello "},{"location":"changing-how-table-matrix-cells-are-drawn/","text":"Changing How TableMatrix Cells Are Drawn If you want to change how the TwoDimensionalArrayDrawer draws its cells you have to add the TableMatrix attribute to the field and supply a method name to the DrawElementMethod parameter of the TableMatrix Attribute. This method name gets resolved using ActionResolvers and will be called for each cell. Inside of this function you use normal Unity GUI functions or Odin's GUI functions to draw the cell's contents. Odin can pass a few arguments to the provided function via NamedValues , these are the possible arguments: Name Type rect Rect element TElement value TElement array TArray x int y int 1 2 3 4 5 6 7 8 9 10 11 12 13 public class SomeMonoBehaviour : SerializedMonoBehaviour { [TableMatrix(DrawElementMethod = nameof(DrawElement))] public GameObject [,] SomeTwoDimensionalArray = new GameObject [ 3 , 3 ]; private GameObject DrawElement ( Rect rect , GameObject value ) { // Draw your cell content here // [...] return value ; } } Here is a small complete example that shows how you could change the preview texture that Odin draws for your class inside the TwoDimensionalArrayDrawer . SomeMonoBehaviour.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using Sirenix.OdinInspector ; using Sirenix.Utilities.Editor ; using UnityEngine ; public class SomeMonoBehaviour : SerializedMonoBehaviour { [TableMatrix(DrawElementMethod = nameof(DrawElement), SquareCells = true)] public Item [,] Items = new Item [ 3 , 3 ]; private Item DrawElement ( Rect rect , Item value ) { return ( Item ) SirenixEditorFields . UnityPreviewObjectField ( rect : rect , value : value , texture : value ?. Preview , // We provide a custom preview texture type : typeof ( Item ) ); } } Item.cs 1 2 3 4 5 6 7 8 9 using UnityEngine ; [CreateAssetMenu] public class Item : ScriptableObject { public string Name ; public string Description ; public Texture2D Preview ; } Default Custom","title":"Changing how table matrix cells are drawn"},{"location":"changing-how-table-matrix-cells-are-drawn/#changing-how-tablematrix-cells-are-drawn","text":"If you want to change how the TwoDimensionalArrayDrawer draws its cells you have to add the TableMatrix attribute to the field and supply a method name to the DrawElementMethod parameter of the TableMatrix Attribute. This method name gets resolved using ActionResolvers and will be called for each cell. Inside of this function you use normal Unity GUI functions or Odin's GUI functions to draw the cell's contents. Odin can pass a few arguments to the provided function via NamedValues , these are the possible arguments: Name Type rect Rect element TElement value TElement array TArray x int y int 1 2 3 4 5 6 7 8 9 10 11 12 13 public class SomeMonoBehaviour : SerializedMonoBehaviour { [TableMatrix(DrawElementMethod = nameof(DrawElement))] public GameObject [,] SomeTwoDimensionalArray = new GameObject [ 3 , 3 ]; private GameObject DrawElement ( Rect rect , GameObject value ) { // Draw your cell content here // [...] return value ; } } Here is a small complete example that shows how you could change the preview texture that Odin draws for your class inside the TwoDimensionalArrayDrawer . SomeMonoBehaviour.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using Sirenix.OdinInspector ; using Sirenix.Utilities.Editor ; using UnityEngine ; public class SomeMonoBehaviour : SerializedMonoBehaviour { [TableMatrix(DrawElementMethod = nameof(DrawElement), SquareCells = true)] public Item [,] Items = new Item [ 3 , 3 ]; private Item DrawElement ( Rect rect , Item value ) { return ( Item ) SirenixEditorFields . UnityPreviewObjectField ( rect : rect , value : value , texture : value ?. Preview , // We provide a custom preview texture type : typeof ( Item ) ); } } Item.cs 1 2 3 4 5 6 7 8 9 using UnityEngine ; [CreateAssetMenu] public class Item : ScriptableObject { public string Name ; public string Description ; public Texture2D Preview ; } Default Custom","title":"Changing How TableMatrix Cells Are Drawn"},{"location":"changing-the-preview-field-preview/","text":"Changing The PreviewField Preview Unfortunately, there is no default way to change the preview that the PreviewField attribute shows because Odin just asks Unity for a preview texture and shows whatever it gets. If you really need it you can create a custom attribute yourself that is capable of showing a different preview texture or you can use the attribute I created called ObjectPreview which has a lot of features that people asked for in the Discord Channel .","title":"Changing the preview field preview"},{"location":"changing-the-preview-field-preview/#changing-the-previewfield-preview","text":"Unfortunately, there is no default way to change the preview that the PreviewField attribute shows because Odin just asks Unity for a preview texture and shows whatever it gets. If you really need it you can create a custom attribute yourself that is capable of showing a different preview texture or you can use the attribute I created called ObjectPreview which has a lot of features that people asked for in the Discord Channel .","title":"Changing The PreviewField Preview"},{"location":"collapse-and-expand-with-code/","text":"Collapse And Expand With Code Odin 3.0.1.0 introduced a new Property States system to properties, accessible through InspectorProperty.State , which manages certain states of properties such as Visible, Expanded and Enabled. We can use it to programatically control the Collapsed/Expanded state of a foldout. Here's an example showing how you would use it on a list that has folded elements inside of it. We're going to add two buttons to the list's title bar that collapse and expand all entries. I'm also going to add the possibility to hold ctrl while doing so to collapse and expand them recursively. SomeMonoBehaviour.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 using Sirenix.OdinInspector ; using Sirenix.OdinInspector.Editor ; using Sirenix.Utilities.Editor ; using System.Collections.Generic ; using UnityEngine ; public class SomeMonoBehaviour : SerializedMonoBehaviour { [ListDrawerSettings(OnTitleBarGUI = \"DrawExpandStateControls\")] public List < SomeData > ListOfSomeData = new List < SomeData >(); private void DrawExpandStateControls ( InspectorProperty property ) { // If one of the buttons is pressed, set the childrens expanded state. // If Event.current.control is true, meaning the user is holding ctrl, expand/collapse them recursively. if ( SirenixEditorGUI . ToolbarButton ( EditorIcons . ArrowDown )) { this . SetChildExpandedState ( property , true , Event . current . control ); } if ( SirenixEditorGUI . ToolbarButton ( EditorIcons . ArrowUp )) { this . SetChildExpandedState ( property , false , Event . current . control ); } } private void SetChildExpandedState ( InspectorProperty property , bool state , bool recursive = false ) { var childProperties = recursive ? property . Children . Recurse () : property . Children ; foreach ( var child in childProperties ) { child . State . Expanded = state ; } } } Used Test Data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class SomeData { public string SomeString ; public float SomeFloat ; public bool SomeBool ; public SomeOtherData SomeOtherData = new SomeOtherData (); } public class SomeOtherData { public string SomeOtherString ; public float SomeOtherFloat ; public bool SomeOtherBool ; } ![](../assets/collapse-and-expand.png) Odin concepts that are used throughout the example - NamedValues - [States] - ActionResolvers","title":"Collapse and expand with code"},{"location":"collapse-and-expand-with-code/#collapse-and-expand-with-code","text":"Odin 3.0.1.0 introduced a new Property States system to properties, accessible through InspectorProperty.State , which manages certain states of properties such as Visible, Expanded and Enabled. We can use it to programatically control the Collapsed/Expanded state of a foldout. Here's an example showing how you would use it on a list that has folded elements inside of it. We're going to add two buttons to the list's title bar that collapse and expand all entries. I'm also going to add the possibility to hold ctrl while doing so to collapse and expand them recursively. SomeMonoBehaviour.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 using Sirenix.OdinInspector ; using Sirenix.OdinInspector.Editor ; using Sirenix.Utilities.Editor ; using System.Collections.Generic ; using UnityEngine ; public class SomeMonoBehaviour : SerializedMonoBehaviour { [ListDrawerSettings(OnTitleBarGUI = \"DrawExpandStateControls\")] public List < SomeData > ListOfSomeData = new List < SomeData >(); private void DrawExpandStateControls ( InspectorProperty property ) { // If one of the buttons is pressed, set the childrens expanded state. // If Event.current.control is true, meaning the user is holding ctrl, expand/collapse them recursively. if ( SirenixEditorGUI . ToolbarButton ( EditorIcons . ArrowDown )) { this . SetChildExpandedState ( property , true , Event . current . control ); } if ( SirenixEditorGUI . ToolbarButton ( EditorIcons . ArrowUp )) { this . SetChildExpandedState ( property , false , Event . current . control ); } } private void SetChildExpandedState ( InspectorProperty property , bool state , bool recursive = false ) { var childProperties = recursive ? property . Children . Recurse () : property . Children ; foreach ( var child in childProperties ) { child . State . Expanded = state ; } } } Used Test Data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class SomeData { public string SomeString ; public float SomeFloat ; public bool SomeBool ; public SomeOtherData SomeOtherData = new SomeOtherData (); } public class SomeOtherData { public string SomeOtherString ; public float SomeOtherFloat ; public bool SomeOtherBool ; } ![](../assets/collapse-and-expand.png) Odin concepts that are used throughout the example - NamedValues - [States] - ActionResolvers","title":"Collapse And Expand With Code"},{"location":"foldout-expanded-by-default/","text":"Foldout Expanded By Default By using a combination of the Property States system and Odin's OnInspectorInit attribute we can set the state of the foldout everytime the inspector initializes. 1 2 3 4 5 6 7 8 9 10 [System.Serializable] public class SomeClass { public float SomeField ; public float SomeOtherField ; public float AnotherField ; } [OnInspectorInit(\"@$property.State.Expanded = true\")] public SomeClass ClassInstance ; The @ sign denotes this string as an Attribute Expression which makes everything behind it be basically treated as normal code. $property is a NamedValue and gives us the InspectorProperty of the ClassInstance field. It holds the foldout's state which we can then set directly.","title":"Foldout expanded by default"},{"location":"foldout-expanded-by-default/#foldout-expanded-by-default","text":"By using a combination of the Property States system and Odin's OnInspectorInit attribute we can set the state of the foldout everytime the inspector initializes. 1 2 3 4 5 6 7 8 9 10 [System.Serializable] public class SomeClass { public float SomeField ; public float SomeOtherField ; public float AnotherField ; } [OnInspectorInit(\"@$property.State.Expanded = true\")] public SomeClass ClassInstance ; The @ sign denotes this string as an Attribute Expression which makes everything behind it be basically treated as normal code. $property is a NamedValue and gives us the InspectorProperty of the ClassInstance field. It holds the foldout's state which we can then set directly.","title":"Foldout Expanded By Default"},{"location":"hide-the-reference-picker/","text":"Hide The Reference Picker You can add the HideReferenceObjectPicker attribute to the class to hide the reference picker. 1 2 3 4 5 6 7 8 [HideReferenceObjectPicker] public interface ISomeInterface { float SomeField { get ; set ; } float SomeOtherField { get ; set ; } } public ISomeInterface SomeInterfaceField ; You can also add the attribute to the SomeInterfaceField instead if you only want to hide the reference picker for that specific instance.","title":"Hide the reference picker"},{"location":"hide-the-reference-picker/#hide-the-reference-picker","text":"You can add the HideReferenceObjectPicker attribute to the class to hide the reference picker. 1 2 3 4 5 6 7 8 [HideReferenceObjectPicker] public interface ISomeInterface { float SomeField { get ; set ; } float SomeOtherField { get ; set ; } } public ISomeInterface SomeInterfaceField ; You can also add the attribute to the SomeInterfaceField instead if you only want to hide the reference picker for that specific instance.","title":"Hide The Reference Picker"},{"location":"missing-features/","text":"Missing Features Unity's package manager sometimes messes up the update which leads to it not actually updating the version and just silently pretending that everything is fine. Make sure that you're actually on the version you believe to be by navigating to Tools > OdinInspector > About . If it's not showing the expected version number delete Unity's package manager cache at %appdata%/Unity/Asset Store-5.x and update Odin again. This usually fixes the problem.","title":"Missing Features"},{"location":"missing-features/#missing-features","text":"Unity's package manager sometimes messes up the update which leads to it not actually updating the version and just silently pretending that everything is fine. Make sure that you're actually on the version you believe to be by navigating to Tools > OdinInspector > About . If it's not showing the expected version number delete Unity's package manager cache at %appdata%/Unity/Asset Store-5.x and update Odin again. This usually fixes the problem.","title":"Missing Features"},{"location":"named-value-list/","text":"Named Value List All Resolvers Name Type property InspectorProperty value TValue AssetList Name Type asset TElement CustomValueDrawer Name Type label GUIContent callNextDrawer Func < GUIContent , bool > TableMatrix Name Type rect Rect element TElement value TElement array TArray x int y int OnCollectionChanged Name Type info CollectionChangeInfo","title":"Named value list"},{"location":"named-value-list/#named-value-list","text":"","title":"Named Value List"},{"location":"named-value-list/#all-resolvers","text":"Name Type property InspectorProperty value TValue","title":"All Resolvers"},{"location":"named-value-list/#assetlist","text":"Name Type asset TElement","title":"AssetList"},{"location":"named-value-list/#customvaluedrawer","text":"Name Type label GUIContent callNextDrawer Func < GUIContent , bool >","title":"CustomValueDrawer"},{"location":"named-value-list/#tablematrix","text":"Name Type rect Rect element TElement value TElement array TArray x int y int","title":"TableMatrix"},{"location":"named-value-list/#oncollectionchanged","text":"Name Type info CollectionChangeInfo","title":"OnCollectionChanged"},{"location":"remove-unitys-default-foldout/","text":"Remove Unity's Default Foldout By adding the InlineProperty Attribute to the class we can tell Odin to draw the contents of the class inline meaning no drop-down will be drawn. 1 2 3 4 5 6 7 8 9 10 [InlineProperty] [System.Serializable] public class SomeClass { public float SomeField ; public float SomeOtherField ; public float AnotherField ; } public SomeClass ClassInstance ; By itself, this will leave the label of the field which will indent all fields contained in the class. Adding the HideLabel Attribute removes that label, leaving us with the desired result. 1 2 3 4 5 6 7 8 9 10 11 [HideLabel] [InlineProperty] [System.Serializable] public class SomeClass { public float SomeField ; public float SomeOtherField ; public float AnotherField ; } public SomeClass ClassInstance ; You can also add these attributes to the ClassInstance instead if you only want that specific instance to not have the drop-down.","title":"Remove unitys default foldout"},{"location":"remove-unitys-default-foldout/#remove-unitys-default-foldout","text":"By adding the InlineProperty Attribute to the class we can tell Odin to draw the contents of the class inline meaning no drop-down will be drawn. 1 2 3 4 5 6 7 8 9 10 [InlineProperty] [System.Serializable] public class SomeClass { public float SomeField ; public float SomeOtherField ; public float AnotherField ; } public SomeClass ClassInstance ; By itself, this will leave the label of the field which will indent all fields contained in the class. Adding the HideLabel Attribute removes that label, leaving us with the desired result. 1 2 3 4 5 6 7 8 9 10 11 [HideLabel] [InlineProperty] [System.Serializable] public class SomeClass { public float SomeField ; public float SomeOtherField ; public float AnotherField ; } public SomeClass ClassInstance ; You can also add these attributes to the ClassInstance instead if you only want that specific instance to not have the drop-down.","title":"Remove Unity's Default Foldout"},{"location":"serialization-doesnt-work/","text":"Serialization Doesn't Work If you're having issues serializing values follow these steps to remove the most common errors. Remove any serialization attributes from your class. Open the Serialization Debugger inside the inspector. You can find it by opening the Context Menu of the MonoBehaviour / ScriptableObject and clicking on Debug Serialization Follow the steps that the debugger recommends at the bottom of the debugger window. If you're trying to serialize a Dictionary and you have issues with it, make sure that you didn't select SerializableDictionary<T1, T2> from the object reference picker.","title":"Serialization Doesn't Work"},{"location":"serialization-doesnt-work/#serialization-doesnt-work","text":"If you're having issues serializing values follow these steps to remove the most common errors. Remove any serialization attributes from your class. Open the Serialization Debugger inside the inspector. You can find it by opening the Context Menu of the MonoBehaviour / ScriptableObject and clicking on Debug Serialization Follow the steps that the debugger recommends at the bottom of the debugger window. If you're trying to serialize a Dictionary and you have issues with it, make sure that you didn't select SerializableDictionary<T1, T2> from the object reference picker.","title":"Serialization Doesn't Work"},{"location":"showif-hideif-multiple-conditions/","text":"ShowIf / HideIf Multiple Conditions In order to be able to have multiple conditions inside a ShowIf / HideIf attribute we have to make use of Odin's Attribute Expressions . They allow us to basically write normal code inside the attributes Resolver string. 1 2 3 4 5 6 7 8 public bool ShowField ; public bool HideField ; [ShowIf(\"@ShowField && !HideField\")] public float SomeField ; [HideIf(\"@!ShowField && HideField\")] public float SomeField ; The @ sign denotes this string as an Attribute Expression and everything behind it is just how you would write it in a normal if statement.","title":"Showif hideif multiple conditions"},{"location":"showif-hideif-multiple-conditions/#showif-hideif-multiple-conditions","text":"In order to be able to have multiple conditions inside a ShowIf / HideIf attribute we have to make use of Odin's Attribute Expressions . They allow us to basically write normal code inside the attributes Resolver string. 1 2 3 4 5 6 7 8 public bool ShowField ; public bool HideField ; [ShowIf(\"@ShowField && !HideField\")] public float SomeField ; [HideIf(\"@!ShowField && HideField\")] public float SomeField ; The @ sign denotes this string as an Attribute Expression and everything behind it is just how you would write it in a normal if statement.","title":"ShowIf / HideIf Multiple Conditions"},{"location":"groups/nesting-groups/","text":"Nesting Groups This tutorial demonstrates how to nest Odin's Group Attributes . We will learn how group paths work and how to handle special cases like the TabGroup attribute. I'm also going to provide a few examples of varying complexity. Group Paths Understanding Odin's group paths are the key to mastering nesting all groups in pretty much every combination imaginable. Odin uses group paths to decide how groups get nested because the order in which attributes are specified in C# is not guaranteed and therefore can't reliably be used to group elements on its own (see Attribute Specification ). Let's begin by creating our first group. SomeMonoBehaviour.cs 1 2 [BoxGroup(\"Box\")] public string SomeField ; We added a BoxGroup attribute to our field and passed it to the string \"Box\" . Let's have a look at the BoxGroup constructor and see what this string is used for. BoxGroup - Constructor 1 2 3 4 5 6 7 public BoxGroupAttribute ( string group , bool showLabel = true , bool centerLabel = false , float order = 0f ) : base ( group , order ) { ShowLabel = showLabel ; CenterLabel = centerLabel ; } As we can see the BoxGroup attribute takes a few arguments, but we'll just focus on the string group parameter for now. We can see that the constructor's body doesn't do anything with this value and instead passes it to the base constructor. Let's have a look at that. PropertyGroupAttribute - Base Constructor 1 2 3 4 5 public PropertyGroupAttribute ( string groupId , float order ) { GroupID = groupId ; [...] } There we have it! The string we pass is used as the group's identifier and we will use it to refer to this group when we want to nest it with other groups. Let's test this knowledge and nest a FoldoutGroup inside the BoxGroup we created earlier. Groups are nested like folder paths so the only thing we need to do is to Add the group attribute Write the first folders name/identifier Add a / Write the second \"folders\" name/identifier SomeMonoBehaviour.cs 1 2 3 [BoxGroup(\"Box\")] [FoldoutGroup(\"Box/Foldout\")] public string SomeField ; The final folder hierarchy now looks like this: 1 2 \ud83d\udcc1 Box \u2514\u2500 \ud83d\udcc1 Foldout We can see that we have a BoxGroup which has a FoldoutGroup inside of it. This is the main benefit of visualizing it like a folder hierarchy, but it also shows that for a group to be nested inside another one, it must first be separately created. Imagine that we didn't declare the BoxGroup our code would look like this: SomeMonoBehaviour.cs 1 2 [FoldoutGroup(\"Box/Foldout\")] public string SomeField ; We're trying to create a Foldout \"folder\" inside a Box \"folder\", but we didn't create the Box \"folder\" so we can't put anything inside of it. 1 2 \u274c Box \u2514\u2500 \ud83d\udcc1 Foldout You do not have to write the BoxGroup attribute before the FoldoutGroup . It just needs to exist inside the file. Since as we've discussed in the beginning, order doesn't matter for attributes. So this still works: SomeMonoBehaviour.cs 1 2 3 [FoldoutGroup(\"Box/Foldout\")] [BoxGroup(\"Box\")] public string SomeField ; These principles apply to all groups and can theoretically be nested as much as you want. We add another group attribute and pass it the full path of identifiers as if it were a folder path. The only group that behaves slightly differently is the TabGroup , which we will look at next. TabGroups are (not) special How to nest TabGroups is probably the most asked question when it comes to nesting groups. We will soon see that it's easier than you might think. Let's start with an example of how most people instinctively try to nest a TabGroup and see why that doesn't work. SomeMonoBehaviour.cs 1 2 3 [TabGroup(\"MyTabs\")] [BoxGroup(\"MyTabs/Box\")] public string SomeField ; Based on our knowledge about group paths, this should work, so what is going on here? Let's investigate a bit and look at the TabGroups constructors to get a better understanding. First TabGroup - Constructor 1 2 3 public TabGroupAttribute ( string tab , bool useFixedHeight = false , float order = 0f ) : this ( \"_DefaultTabGroup\" , tab , useFixedHeight , order ) { } Second TabGroup - Constructor 1 2 3 public TabGroupAttribute ( string group , string tab , bool useFixedHeight = false , float order = 0f ) : base ( group , order ) { } The first thing that we've found out is that the TabGroup has two constructors. We're using the first one in our example since it's the only one that has only one non-optional parameter string tab . Judging by the names we can see that we're passing the tab name and not the group identifier. This explains why it's not working, but how does Odin identify the group if we don't specify one ourselves? The answer is simple, Odin calls the second constructor and assigns \"_DefaultTabGroup\" as the group identifier. Now you're maybe thinking \"I just have to change my identifier to \"_DefaultTabGroup\" and I'm good to go\". Unfortunately, this is still not the solution. The TabGroups identifier consists of the group identifier and the tab name and if we think about it, it makes sense. How else could Odin know in what tab you want to put your nested groups? We can now build our group path successfully by Writing \"_DefaultTabGroup\" Adding a \\ Writin the tab name SomeMonoBehaviour.cs 1 2 3 4 5 // I changed the name to 'Tab01' instead of MyTabs // since we now know that this is actually the tab name. [TabGroup(\"Tab01\")] [BoxGroup(\"_DefaultTabGroup/Tab01/Box\")] public string SomeField ; We now have a working TabGroup nesting example, but it's still not ideal. I know, I know, but we're almost there. Using this method has several drawbacks. \"_DefaultTabGroup\" is hard to read. \"_DefaultTabGroup\" seems to magically exist without us creating it in the file leading to confusion. What do we do if we have multiple TabGroups? They would all have the same group identifier leading to undesired and hard to debug behaviour. What's the solution? It's quite simple. Instead of letting Odin call the second constructor and passing it the \"_DefaultTabGroup\" string, we call it ourselves and pass the group identifier and the tab name at once. We can then just substitute the \"_DefaultTabGroup\" string with our group identifier. SomeMonoBehaviour.cs 1 2 3 [TabGroup(\"MyTabGroup\", \"Tab01\")] [BoxGroup(\"MyTabGroup/Tab01/Box\")] public string SomeField ; That's it! You should now be able to nest all of Odin's groups no matter the complexity by simply applying the rules you learned. If you're having problems remembering the correct syntax just keep the folder analogy in mind. 1 2 3 \ud83d\udcc1 MyTabGroup \u2514\u2500 \ud83d\udcc1 Tab01 \u2514\u2500 \ud83d\udcc1 Box Examples BoxGroups in a BoxGroup 1 2 3 4 5 6 7 8 9 [BoxGroup(\"Box\")] public string SomeField ; [HorizontalGroup(\"Box/Horizontal\")] [BoxGroup(\"Box/Horizontal/BoxRight\")] public string SomeOtherField ; [BoxGroup(\"Box/Horizontal/BoxLeft\")] public string AnotherOne ; BoxGroup in a ShowIfGroup 1 2 3 4 5 [ShowIfGroup(\"PossiblyVisibleGroup\", Condition = nameof(ShowGroup))] [BoxGroup(\"PossiblyVisibleGroup/Box\")] public string SomeField ; public bool ShowGroup ; BoxGroups in a TabGroup 1 2 3 4 5 6 7 [TabGroup(\"Tabs\", \"Tab01\")] [BoxGroup(\"Tabs/Tab01/Box\")] public string SomeField ; [TabGroup(\"Tabs\", \"Tab02\")] [BoxGroup(\"Tabs/Tab02/Box\")] public string SomeOtherField ; TabGroup in a TabGroup 1 2 3 4 5 6 [TabGroup(\"OuterTabGroup\", \"OuterTab01\")] [TabGroup(\"OuterTabGroup/OuterTab01/InnerTabGroup\", \"InnerTab01\")] public string SomeField ; [TabGroup(\"OuterTabGroup\", \"OuterTab02\")] public string SomeOtherField ; BoxGroup in a TabGroup in a ToggleGroup 1 2 3 4 5 6 7 8 9 [ToggleGroup(\"Toggled\")] public bool Toggled ; [TabGroup(\"Toggled/Tabs\", \"Tab01\")] public string SomeField ; [TabGroup(\"Toggled/Tabs\", \"Tab02\")] [BoxGroup(\"Toggled/Tabs/Tab02/Box\")] public string SomeOtherField ; What even...? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 [ToggleGroup(\"Toggled\")] public bool Toggled ; [HorizontalGroup(\"Toggled/Horizontal\")] [FoldoutGroup(\"Toggled/Horizontal/FoldoutRight\")] [TabGroup(\"Toggled/Horizontal/FoldoutRight/TabsRight\", \"Tab01\")] [BoxGroup(\"Toggled/Horizontal/FoldoutRight/TabsRight/Tab01/Box\")] public string SomeField ; [TabGroup(\"Toggled/Horizontal/FoldoutRight/TabsRight\", \"Tab02\")] [BoxGroup(\"Toggled/Horizontal/FoldoutRight/TabsRight/Tab02/Box\")] public string SomeOtherField ; [FoldoutGroup(\"Toggled/Horizontal/FoldoutLeft\")] [TabGroup(\"Toggled/Horizontal/FoldoutLeft/TabsLeft\", \"Tab01\")] [BoxGroup(\"Toggled/Horizontal/FoldoutLeft/TabsLeft/Tab01/Box\")] public string AnotherOne ; [TabGroup(\"Toggled/Horizontal/FoldoutLeft/TabsLeft\", \"Tab02\")] [BoxGroup(\"Toggled/Horizontal/FoldoutLeft/TabsLeft/Tab02/Box\")] public string YetAnotherOne ; Gotchas If you have missing or duplicate elements, make sure to check your group path, this is a sign that you did not nest your group correctly.","title":"Nesting groups"},{"location":"groups/nesting-groups/#nesting-groups","text":"This tutorial demonstrates how to nest Odin's Group Attributes . We will learn how group paths work and how to handle special cases like the TabGroup attribute. I'm also going to provide a few examples of varying complexity. Group Paths Understanding Odin's group paths are the key to mastering nesting all groups in pretty much every combination imaginable. Odin uses group paths to decide how groups get nested because the order in which attributes are specified in C# is not guaranteed and therefore can't reliably be used to group elements on its own (see Attribute Specification ). Let's begin by creating our first group. SomeMonoBehaviour.cs 1 2 [BoxGroup(\"Box\")] public string SomeField ; We added a BoxGroup attribute to our field and passed it to the string \"Box\" . Let's have a look at the BoxGroup constructor and see what this string is used for. BoxGroup - Constructor 1 2 3 4 5 6 7 public BoxGroupAttribute ( string group , bool showLabel = true , bool centerLabel = false , float order = 0f ) : base ( group , order ) { ShowLabel = showLabel ; CenterLabel = centerLabel ; } As we can see the BoxGroup attribute takes a few arguments, but we'll just focus on the string group parameter for now. We can see that the constructor's body doesn't do anything with this value and instead passes it to the base constructor. Let's have a look at that. PropertyGroupAttribute - Base Constructor 1 2 3 4 5 public PropertyGroupAttribute ( string groupId , float order ) { GroupID = groupId ; [...] } There we have it! The string we pass is used as the group's identifier and we will use it to refer to this group when we want to nest it with other groups. Let's test this knowledge and nest a FoldoutGroup inside the BoxGroup we created earlier. Groups are nested like folder paths so the only thing we need to do is to Add the group attribute Write the first folders name/identifier Add a / Write the second \"folders\" name/identifier SomeMonoBehaviour.cs 1 2 3 [BoxGroup(\"Box\")] [FoldoutGroup(\"Box/Foldout\")] public string SomeField ; The final folder hierarchy now looks like this: 1 2 \ud83d\udcc1 Box \u2514\u2500 \ud83d\udcc1 Foldout We can see that we have a BoxGroup which has a FoldoutGroup inside of it. This is the main benefit of visualizing it like a folder hierarchy, but it also shows that for a group to be nested inside another one, it must first be separately created. Imagine that we didn't declare the BoxGroup our code would look like this: SomeMonoBehaviour.cs 1 2 [FoldoutGroup(\"Box/Foldout\")] public string SomeField ; We're trying to create a Foldout \"folder\" inside a Box \"folder\", but we didn't create the Box \"folder\" so we can't put anything inside of it. 1 2 \u274c Box \u2514\u2500 \ud83d\udcc1 Foldout You do not have to write the BoxGroup attribute before the FoldoutGroup . It just needs to exist inside the file. Since as we've discussed in the beginning, order doesn't matter for attributes. So this still works: SomeMonoBehaviour.cs 1 2 3 [FoldoutGroup(\"Box/Foldout\")] [BoxGroup(\"Box\")] public string SomeField ; These principles apply to all groups and can theoretically be nested as much as you want. We add another group attribute and pass it the full path of identifiers as if it were a folder path. The only group that behaves slightly differently is the TabGroup , which we will look at next. TabGroups are (not) special How to nest TabGroups is probably the most asked question when it comes to nesting groups. We will soon see that it's easier than you might think. Let's start with an example of how most people instinctively try to nest a TabGroup and see why that doesn't work. SomeMonoBehaviour.cs 1 2 3 [TabGroup(\"MyTabs\")] [BoxGroup(\"MyTabs/Box\")] public string SomeField ; Based on our knowledge about group paths, this should work, so what is going on here? Let's investigate a bit and look at the TabGroups constructors to get a better understanding. First TabGroup - Constructor 1 2 3 public TabGroupAttribute ( string tab , bool useFixedHeight = false , float order = 0f ) : this ( \"_DefaultTabGroup\" , tab , useFixedHeight , order ) { } Second TabGroup - Constructor 1 2 3 public TabGroupAttribute ( string group , string tab , bool useFixedHeight = false , float order = 0f ) : base ( group , order ) { } The first thing that we've found out is that the TabGroup has two constructors. We're using the first one in our example since it's the only one that has only one non-optional parameter string tab . Judging by the names we can see that we're passing the tab name and not the group identifier. This explains why it's not working, but how does Odin identify the group if we don't specify one ourselves? The answer is simple, Odin calls the second constructor and assigns \"_DefaultTabGroup\" as the group identifier. Now you're maybe thinking \"I just have to change my identifier to \"_DefaultTabGroup\" and I'm good to go\". Unfortunately, this is still not the solution. The TabGroups identifier consists of the group identifier and the tab name and if we think about it, it makes sense. How else could Odin know in what tab you want to put your nested groups? We can now build our group path successfully by Writing \"_DefaultTabGroup\" Adding a \\ Writin the tab name SomeMonoBehaviour.cs 1 2 3 4 5 // I changed the name to 'Tab01' instead of MyTabs // since we now know that this is actually the tab name. [TabGroup(\"Tab01\")] [BoxGroup(\"_DefaultTabGroup/Tab01/Box\")] public string SomeField ; We now have a working TabGroup nesting example, but it's still not ideal. I know, I know, but we're almost there. Using this method has several drawbacks. \"_DefaultTabGroup\" is hard to read. \"_DefaultTabGroup\" seems to magically exist without us creating it in the file leading to confusion. What do we do if we have multiple TabGroups? They would all have the same group identifier leading to undesired and hard to debug behaviour. What's the solution? It's quite simple. Instead of letting Odin call the second constructor and passing it the \"_DefaultTabGroup\" string, we call it ourselves and pass the group identifier and the tab name at once. We can then just substitute the \"_DefaultTabGroup\" string with our group identifier. SomeMonoBehaviour.cs 1 2 3 [TabGroup(\"MyTabGroup\", \"Tab01\")] [BoxGroup(\"MyTabGroup/Tab01/Box\")] public string SomeField ; That's it! You should now be able to nest all of Odin's groups no matter the complexity by simply applying the rules you learned. If you're having problems remembering the correct syntax just keep the folder analogy in mind. 1 2 3 \ud83d\udcc1 MyTabGroup \u2514\u2500 \ud83d\udcc1 Tab01 \u2514\u2500 \ud83d\udcc1 Box Examples BoxGroups in a BoxGroup 1 2 3 4 5 6 7 8 9 [BoxGroup(\"Box\")] public string SomeField ; [HorizontalGroup(\"Box/Horizontal\")] [BoxGroup(\"Box/Horizontal/BoxRight\")] public string SomeOtherField ; [BoxGroup(\"Box/Horizontal/BoxLeft\")] public string AnotherOne ; BoxGroup in a ShowIfGroup 1 2 3 4 5 [ShowIfGroup(\"PossiblyVisibleGroup\", Condition = nameof(ShowGroup))] [BoxGroup(\"PossiblyVisibleGroup/Box\")] public string SomeField ; public bool ShowGroup ; BoxGroups in a TabGroup 1 2 3 4 5 6 7 [TabGroup(\"Tabs\", \"Tab01\")] [BoxGroup(\"Tabs/Tab01/Box\")] public string SomeField ; [TabGroup(\"Tabs\", \"Tab02\")] [BoxGroup(\"Tabs/Tab02/Box\")] public string SomeOtherField ; TabGroup in a TabGroup 1 2 3 4 5 6 [TabGroup(\"OuterTabGroup\", \"OuterTab01\")] [TabGroup(\"OuterTabGroup/OuterTab01/InnerTabGroup\", \"InnerTab01\")] public string SomeField ; [TabGroup(\"OuterTabGroup\", \"OuterTab02\")] public string SomeOtherField ; BoxGroup in a TabGroup in a ToggleGroup 1 2 3 4 5 6 7 8 9 [ToggleGroup(\"Toggled\")] public bool Toggled ; [TabGroup(\"Toggled/Tabs\", \"Tab01\")] public string SomeField ; [TabGroup(\"Toggled/Tabs\", \"Tab02\")] [BoxGroup(\"Toggled/Tabs/Tab02/Box\")] public string SomeOtherField ; What even...? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 [ToggleGroup(\"Toggled\")] public bool Toggled ; [HorizontalGroup(\"Toggled/Horizontal\")] [FoldoutGroup(\"Toggled/Horizontal/FoldoutRight\")] [TabGroup(\"Toggled/Horizontal/FoldoutRight/TabsRight\", \"Tab01\")] [BoxGroup(\"Toggled/Horizontal/FoldoutRight/TabsRight/Tab01/Box\")] public string SomeField ; [TabGroup(\"Toggled/Horizontal/FoldoutRight/TabsRight\", \"Tab02\")] [BoxGroup(\"Toggled/Horizontal/FoldoutRight/TabsRight/Tab02/Box\")] public string SomeOtherField ; [FoldoutGroup(\"Toggled/Horizontal/FoldoutLeft\")] [TabGroup(\"Toggled/Horizontal/FoldoutLeft/TabsLeft\", \"Tab01\")] [BoxGroup(\"Toggled/Horizontal/FoldoutLeft/TabsLeft/Tab01/Box\")] public string AnotherOne ; [TabGroup(\"Toggled/Horizontal/FoldoutLeft/TabsLeft\", \"Tab02\")] [BoxGroup(\"Toggled/Horizontal/FoldoutLeft/TabsLeft/Tab02/Box\")] public string YetAnotherOne ; Gotchas If you have missing or duplicate elements, make sure to check your group path, this is a sign that you did not nest your group correctly.","title":"Nesting Groups"},{"location":"groups/space-between-groups/","text":"Space Between Groups As of now the VerticalGroup is the only group that has parameters to add vertical spacing. In order to add vertical spacing to other groups you have to nest them inside a VerticalGroup like this. 1 2 3 [VerticalGroup(\"Space\", PaddingTop = 20f, PaddingBottom = 20f)] [BoxGroup(\"Space/Box\")] public float SomeField ; The VerticalGroups sole purpose in this case is to add vertical spacing using the PaddingTop & PaddingBottom parameters. The same principle applies to all other groups.","title":"Space between groups"},{"location":"groups/space-between-groups/#space-between-groups","text":"As of now the VerticalGroup is the only group that has parameters to add vertical spacing. In order to add vertical spacing to other groups you have to nest them inside a VerticalGroup like this. 1 2 3 [VerticalGroup(\"Space\", PaddingTop = 20f, PaddingBottom = 20f)] [BoxGroup(\"Space/Box\")] public float SomeField ; The VerticalGroups sole purpose in this case is to add vertical spacing using the PaddingTop & PaddingBottom parameters. The same principle applies to all other groups.","title":"Space Between Groups"}]}